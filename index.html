<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mask-Based Diffusion for Music Generation</title>
    <style>
        /* --- Basic Setup & Fonts --- */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600;700&display.swap');

        :root {
            --bg-color: #1a1a1d;
            --container-bg: #2c2c30;
            --border-color: #4b4b53;
            --text-color: #e0e0e0;
            --text-muted: #a0a0a0;
            --primary-color: #9f7aea;
            --highlight-color: #f6ad55;
            --font-main: 'Inter', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        body { font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; padding: 2rem 1rem; }

        /* --- Main Layout & Typography --- */
        .main-container { width: 100%; max-width: 900px; text-align: center; }
        .header h1 { font-size: 2.8rem; font-weight: 700; margin-bottom: 0.5rem; color: var(--primary-color); }
        h2 { font-size: 2.2rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--text-color); border-bottom: 2px solid var(--primary-color); display: inline-block; padding-bottom: 0.5rem; }
        .section { margin-bottom: 4rem; }
        .section-divider { border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0, 0, 0, 0), var(--border-color), rgba(0, 0, 0, 0)); margin: 4rem 0; }

        /* --- Audio Showcase Styles --- */
        .audio-showcase { background-color: var(--container-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; text-align: center; }
        th, td { padding: 1rem; vertical-align: middle; }
        thead th { font-size: 1.1rem; font-weight: 600; color: var(--highlight-color); border-bottom: 2px solid var(--border-color); padding-bottom: 1.2rem; }
        tbody tr:not(:last-child) td { border-bottom: 1px solid var(--border-color); }
        td:first-child { font-weight: 600; color: var(--text-color); font-size: 1.1rem; }
        audio { width: 100%; min-width: 250px; }
        
        /* --- Interactive Animation & Controls --- */
        .matrix-container { max-width: 600px; margin: 0 auto; position: relative; }
        .matrix-grid { display: grid; gap: 1px; background-color: var(--bg-color); border: 2px solid var(--border-color); border-radius: 10px; padding: 5px; margin: 0 auto 1.5rem auto; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); cursor: none; }
        .cell { background-color: #000; aspect-ratio: 1 / 1; transition: background-color 0.4s ease; }

        .parameter-controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; background-color: var(--container-bg); padding: 1.5rem; border-radius: 10px; border: 1px solid var(--border-color); margin-bottom: 1.5rem; }
        .param { text-align: left; }
        .param label { display: block; font-weight: 600; margin-bottom: 0.75rem; }
        .param span { font-family: var(--font-mono); background-color: var(--bg-color); padding: 0.2rem 0.5rem; border-radius: 4px; color: var(--highlight-color); }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #444; border-radius: 5px; outline: none; margin-top: 0.5rem; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--primary-color); border-radius: 50%; cursor: pointer; border: 3px solid var(--container-bg); transition: background-color 0.2s ease; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: var(--primary-color); border-radius: 50%; cursor: pointer; border: 3px solid var(--container-bg); transition: background-color 0.2s ease; }

        .controls { display: flex; justify-content: center; align-items: center; gap: 1.5rem; margin-bottom: 1.5rem; }
        .control-btn { background: linear-gradient(45deg, var(--primary-color), #805ad5); color: white; border: none; padding: 12px 24px; font-size: 1rem; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .control-btn:disabled { background: #555; cursor: not-allowed; transform: none; box-shadow: none;}
        .control-btn:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(159, 122, 234, 0.4); }
        .control-btn#reset-btn { background: #4a4a50; }
        
        /* --- Toggle Switch for Inspector --- */
        .inspector-toggle-label { display: flex; align-items: center; gap: 0.75rem; font-weight: 600; }
        .toggle-switch { position: relative; display: inline-block; width: 52px; height: 30px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 30px; }
        .toggle-slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: var(--primary-color); }
        input:checked + .toggle-slider:before { transform: translateX(22px); }

        .step-description { background-color: var(--container-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; min-height: 100px; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .step-title { font-size: 1.2rem; font-weight: 600; color: var(--highlight-color); margin-bottom: 0.5rem; }
        .step-formula { font-family: var(--font-mono); font-size: 1rem; color: #c0c0c0; }
        
        /* --- Precision Magnifier & Crosshair System --- */
        .magnifier, .custom-crosshair { position: fixed; pointer-events: none; display: none; z-index: 9999; transition: top 0.05s, left 0.05s; }
        .magnifier { width: 150px; height: 150px; border: 3px solid var(--primary-color); border-radius: 50%; overflow: hidden; background-color: var(--bg-color); box-shadow: 0 5px 25px rgba(0,0,0,0.5); transform: translate(25px, 25px); transition: none; }
        .magnifier-grid { display: grid; grid-template-columns: repeat(5, 1fr); width: 100%; height: 100%; }
        
        .magnifier-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-mono);
            font-size: 0.8rem;   /* â¬† bumped up for better fill */
            color: #fff;
            text-shadow: 0 0 2px black;

            /* ðŸ”‘ Fixed equal sizing */
            width: 5.5ch;        /* wide enough for "255.0" */
            height: 2.2em;       /* a little taller for balance */
            box-sizing: border-box;
            overflow: hidden;
            text-align: center;
        }

        /* FINAL FIX: Using 'border' instead of 'outline' to prevent clipping by the parent's overflow:hidden */
        .magnifier-cell:nth-child(13) {
            font-weight: 700;
            border: 2px solid var(--primary-color);
        }


        .custom-crosshair { background-color: rgba(159, 122, 234, 0.7); } /* --primary-color with transparency */
        #crosshair-h { height: 2px; transform: translateY(-1px); }
        #crosshair-v { width: 2px; transform: translateX(-1px); }
    </style>
</head>
<body>
    <!-- Precision Inspection Tools (placed outside main content for fixed positioning) -->
    <div class="magnifier" id="magnifier"><div class="magnifier-grid" id="magnifierGrid"></div></div>
    <div class="custom-crosshair" id="crosshair-h"></div>
    <div class="custom-crosshair" id="crosshair-v"></div>

    <main class="main-container">
        <header class="header"><h1>Mask-Based Diffusion for Music Generation</h1></header>

        <section id="examples" class="section">
            <h2>Noise-to-Music Examples</h2>
            <div class="audio-showcase">
                <table>
                    <thead><tr><th>ðŸ“– Noise Sample</th><th>ðŸŽ§ Noise Input</th><th>ðŸŽ¼ Music Output</th></tr></thead>
                    <tbody>
                        <tr><td>A passing train</td><td><audio controls><source src="inputs/train_passing_input.wav" type="audio/wav"></audio></td><td><audio controls><source src="outputs/train_passing_output.wav" type="audio/wav"></audio></td></tr>
                        <tr><td>A ticking clock</td><td><audio controls><source src="inputs/clock_ticking_input.wav" type="audio/wav"></audio></td><td><audio controls><source src="outputs/clock_ticking_output.wav" type="audio/wav"></audio></td></tr>
                        <tr><td>A cuckoo clock</td><td><audio controls><source src="inputs/cuckoo_clock_input.wav" type="audio/wav"></audio></td><td><audio controls><source src="outputs/cuckoo_clock_output.wav" type="audio/wav"></audio></td></tr>
                        <tr><td>Coin sound from Mario</td><td><audio controls><source src="inputs/mario_coin_input.wav" type="audio/wav"></audio></td><td><audio controls><source src="outputs/mario_coin_output.wav" type="audio/wav"></audio></td></tr>
                        <tr><td>A honking truck</td><td><audio controls><source src="inputs/loud_honking_input.wav" type="audio/wav"></audio></td><td><audio controls><source src="outputs/loud_honking_output.wav" type="audio/wav"></audio></td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <hr class="section-divider">

        <section id="animation" class="section">
            <h2>Interactive Mask Generation</h2>
            <div class="matrix-container">
                <div class="parameter-controls">
                    <div class="param"><label>Brightness Factor: <span id="brightness-value">0.05</span></label><input type="range" id="brightness" min="0" max="1" step="0.01" value="0.05"></div>
                    <div class="param"><label>Contrast Factor: <span id="contrast-value">200</span></label><input type="range" id="contrast" min="1" max="500" step="1" value="200"></div>
                    <div class="param"><label>Downshift Value: <span id="downshift-value">40</span></label><input type="range" id="downshift" min="0" max="255" step="1" value="40"></div>
                    <div class="param"><label>Animation Speed: <span id="speed-value">2.5s</span></label><input type="range" id="speed" min="500" max="5000" step="100" value="2500"></div>
                </div>
                 <div class="matrix-grid" id="matrixGrid"></div>
                 <div class="controls">
                    <button class="control-btn" id="start-btn">Start</button>
                    <button class="control-btn" id="reset-btn">Reset</button>
                    <label class="inspector-toggle-label">
                        Inspector
                        <label class="toggle-switch">
                            <input type="checkbox" id="inspector-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </label>
                </div>
                <div class="step-description">
                    <div class="step-title" id="stepTitle">Ready</div>
                    <div class="step-formula" id="stepFormula">Adjust sliders and click "Start" to see the mask generation.</div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // --- CONFIGURATION ---
        const GRID_SIZE = 50;
        const MAGNIFIER_SIZE = 5; // Must be an odd number

        // --- DOM Elements ---
        const grid = document.getElementById('matrixGrid');
        const magnifier = document.getElementById('magnifier');
        const magnifierGrid = document.getElementById('magnifierGrid');
        const crosshairH = document.getElementById('crosshair-h');
        const crosshairV = document.getElementById('crosshair-v');
        const inspectorToggle = document.getElementById('inspector-toggle');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const stepTitleEl = document.getElementById('stepTitle');
        const stepFormulaEl = document.getElementById('stepFormula');
        const sliders = { brightness: document.getElementById('brightness'), contrast: document.getElementById('contrast'), downshift: document.getElementById('downshift'), speed: document.getElementById('speed') };
        const values = { brightness: document.getElementById('brightness-value'), contrast: document.getElementById('contrast-value'), downshift: document.getElementById('downshift-value'), speed: document.getElementById('speed-value') };

        // --- State Variables ---
        let masterMatrix = [];
        let displayedMatrix = [];
        let currentStep = 0;
        let isAnimating = false;
        let isPaused = false;
        let animationTimeoutId = null;
        let cells = [];
        let magnifierCells = [];
        let params = { brightness: 0.05, contrast: 200, downshift: 40, speed: 2500 };
        let animationSteps = [];
        let currentMean = 0;
        let isInspectorEnabled = true;
        let lastInspectedCellIndex = -1;

        // --- Matrix Calculation Logic ---
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
        function generateInitialMatrix(size) { let matrix = Array(size).fill(0).map(() => Array(size).fill(0)); const centerCol = size / 2; for (let r = 0; r < size; r++) { for (let c = 0; c < size; c++) { const trunkDist = Math.abs(c - centerCol); let trunkVal = (trunkDist < 1.5) ? (1 - (r / (size * 1.2))) * (200 - trunkDist * 40) * (1 + (Math.random() - 0.5) * 0.2) : 0; let branchVal = 0; for (let i = 1; i <= 4; i++) { if (r > size * 0.1 * i) { const slope = 0.4 + i * 0.3; const branchDist = Math.abs(Math.abs(c - centerCol) - (r - size * 0.1 * i) * slope); if (branchDist < 1) branchVal = Math.max(branchVal, (150 - i * 25) * (1 - branchDist)); } } matrix[r][c] = Math.max(trunkVal, branchVal); } } return matrix.map(row => row.map(val => 255 - clamp(val + (Math.random() * 40), 0, 255))); }
        function calculateStep(inputMatrix, stepIndex, p) { switch (stepIndex) { case 1: return inputMatrix.map(row => row.map(val => 255 - val)); case 2: return inputMatrix.map(row => row.map(val => val * p.brightness)); case 3: const flat = inputMatrix.flat(); currentMean = flat.reduce((a, b) => a + b, 0) / flat.length; return inputMatrix.map(row => row.map(val => clamp(currentMean + p.contrast * (val - currentMean), 0, 255))); case 4: return inputMatrix.map(row => row.map(val => clamp(val - p.downshift, 0, 255))); default: return inputMatrix; } }
        
        // --- UI & Animation Functions ---
        const toGrayscale = (value) => `hsl(0, 0%, ${clamp(value / 255 * 100, 0, 100)}%)`;
        function updateGrid(matrix) { displayedMatrix = matrix; matrix.flat().forEach((value, i) => { cells[i].style.backgroundColor = toGrayscale(value); }); }
        function updateDescription(step) { stepTitleEl.textContent = step.title; stepFormulaEl.textContent = step.formula(params, currentMean); }
        function runAnimation() { if (isPaused) return; if (currentStep >= animationSteps.length) { isAnimating = false; isPaused = false; startBtn.textContent = 'Start'; return; } const stepInfo = animationSteps[currentStep]; const prevMatrix = (currentStep === 0) ? masterMatrix : displayedMatrix; const nextMatrix = calculateStep(prevMatrix, currentStep, params); updateDescription(stepInfo); updateGrid(nextMatrix); currentStep++; animationTimeoutId = setTimeout(runAnimation, params.speed); }
        function handleStartPauseResume() { if (!isAnimating) { isAnimating = true; startBtn.textContent = 'Pause'; currentStep = 0; runAnimation(); } else if (isPaused) { isPaused = false; startBtn.textContent = 'Pause'; runAnimation(); } else { isPaused = true; clearTimeout(animationTimeoutId); startBtn.textContent = 'Resume'; } }
        function reset() { clearTimeout(animationTimeoutId); isAnimating = false; isPaused = false; sliders.brightness.value = 0.05; sliders.contrast.value = 200; sliders.downshift.value = 40; sliders.speed.value = 2500; Object.values(sliders).forEach(slider => slider.dispatchEvent(new Event('input'))); updateGrid(masterMatrix); updateDescription(animationSteps[0]); startBtn.disabled = false; startBtn.textContent = 'Start'; }

        // --- Precision Magnifier & Crosshair Logic ---
        function updateMagnifier(row, col) { const halfSize = Math.floor(MAGNIFIER_SIZE / 2); for (let r = 0; r < MAGNIFIER_SIZE; r++) { for (let c = 0; c < MAGNIFIER_SIZE; c++) { const targetRow = row + r - halfSize; const targetCol = col + c - halfSize; const cellIndex = r * MAGNIFIER_SIZE + c; const inBounds = targetRow >= 0 && targetRow < GRID_SIZE && targetCol >= 0 && targetCol < GRID_SIZE; if (inBounds) { const value = displayedMatrix[targetRow][targetCol]; magnifierCells[cellIndex].textContent = value.toFixed(1); magnifierCells[cellIndex].style.backgroundColor = toGrayscale(value); } else { magnifierCells[cellIndex].textContent = ''; magnifierCells[cellIndex].style.backgroundColor = 'var(--bg-color)'; } } } }
        function hideInspectorTools() { magnifier.style.display = 'none'; crosshairH.style.display = 'none'; crosshairV.style.display = 'none'; }
        
        function init() {
            // --- Pixel-Perfect Grid Setup ---
            const CELL_PIXEL_SIZE = 10;
            const GAP_PIXEL_SIZE = 1;
            const PADDING_PIXEL_SIZE = 5; // Must match CSS .matrix-grid padding
            
            const gridContentWidth = (GRID_SIZE * CELL_PIXEL_SIZE) + ((GRID_SIZE - 1) * GAP_PIXEL_SIZE);
            const totalGridWidth = gridContentWidth + (PADDING_PIXEL_SIZE * 2);
            grid.style.width = `${totalGridWidth}px`;
            grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_PIXEL_SIZE}px)`;

            animationSteps = [ { title: 'Initial Spectrogram', formula: () => 'Generated "Pine Tree" Spectrogram Pattern' }, { title: 'Step 1: Inversion', formula: () => 'M\' = 255 - M' }, { title: 'Step 2: Brightness', formula: (p) => `M\' = M Ã— ${p.brightness.toFixed(2)}` }, { title: 'Step 3: Contrast', formula: (p, mean) => `Î¼ = ${mean.toFixed(1)} | M\' = clip(Î¼ + ${p.contrast} Ã— (M - Î¼), 0, 255)` }, { title: 'Step 4: Downshift', formula: (p) => `M\' = max(M - ${p.downshift}, 0)` }, { title: 'Final Mask', formula: () => 'The mask generation is complete.' } ];
            
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) { const cell = document.createElement('div'); cell.classList.add('cell'); grid.appendChild(cell); cells.push(cell); }
            for (let i = 0; i < MAGNIFIER_SIZE * MAGNIFIER_SIZE; i++) { const cell = document.createElement('div'); cell.classList.add('magnifier-cell'); magnifierGrid.appendChild(cell); magnifierCells.push(cell); }
            masterMatrix = generateInitialMatrix(GRID_SIZE);
            
            Object.values(sliders).forEach(slider => slider.addEventListener('input', (e) => { const { id, value } = e.target; params[id] = Number(value); values[id].textContent = id === 'speed' ? `${(value/1000).toFixed(1)}s` : (id === 'brightness' ? Number(value).toFixed(2) : value); }));
            
            inspectorToggle.addEventListener('change', (e) => { isInspectorEnabled = e.target.checked; grid.style.cursor = isInspectorEnabled ? 'none' : 'crosshair'; if (!isInspectorEnabled) hideInspectorTools(); });
            
            window.addEventListener('mousemove', (e) => {
                const rect = grid.getBoundingClientRect();
                const isOverGrid = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
                
                if (isOverGrid && isInspectorEnabled) {
                    magnifier.style.display = 'block'; crosshairH.style.display = 'block'; crosshairV.style.display = 'block';
                    magnifier.style.top = `${e.clientY}px`; magnifier.style.left = `${e.clientX}px`;
                    
                    const col = Math.floor(((e.clientX - rect.left) / grid.clientWidth) * GRID_SIZE);
                    const row = Math.floor(((e.clientY - rect.top) / grid.clientHeight) * GRID_SIZE);
                    const cellIndex = row * GRID_SIZE + col;
                    
                    if (cellIndex !== lastInspectedCellIndex) {
                        lastInspectedCellIndex = cellIndex;
                        const cellElement = cells[cellIndex];
                        if (cellElement) {
                            const cellRect = cellElement.getBoundingClientRect();
                            const centerX = cellRect.left + cellRect.width / 2;
                            const centerY = cellRect.top + cellRect.height / 2;

                            crosshairH.style.top = `${centerY}px`; crosshairH.style.left = `${rect.left}px`; crosshairH.style.width = `${rect.width}px`;
                            crosshairV.style.left = `${centerX}px`; crosshairV.style.top = `${rect.top}px`; crosshairV.style.height = `${rect.height}px`;
                            
                            updateMagnifier(row, col);
                        }
                    }
                } else {
                    lastInspectedCellIndex = -1;
                    hideInspectorTools();
                }
            });
            
            startBtn.addEventListener('click', handleStartPauseResume);
            resetBtn.addEventListener('click', reset);
            
            reset();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>